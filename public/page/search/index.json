[{"content":"Funções são populares na maiorias da linguagens de programação. Elas oferecem maneiras de encapsular trechos de código que podem ser reaproveitados em partes distintas de um programa, possibilitando dividir grandes tarefas em partes menores, tornando-se um grande pilar na modularização.\nEm Go, as funções têm uma estrutura de definição com o nome, uma lista de parâmetros de entrada especificando o nome e o tipo das variáveis. Estas variáveis recebem os valores dos argumentos passados na chamada da função e que tem escopo local, também uma lista de parâmetros de saída que podem ser capturados no retorno após a função ser executada. Confira o exemplo abaixo de uma função que recebe dois argumentos inteiros \u0026ldquo;a\u0026rdquo; e \u0026ldquo;b\u0026rdquo; e retorna a soma dos dois inteiros.\nfunc Sum(a int, b int) (int) { return a + b } Existem também outras maneiras também de fazer a declaração de funções, podendo fazer a omissão de alguns parênteses quando é retornando somente um valor, o agrupamento de variáveis de mesmo tipo na declaração de argumentos, também podendo ser agrupado a lista de retorno. Pode-se nomear os valores retornados na lista de retorno e fazendo a omissão dos valores na função \u0026ldquo;return\u0026rdquo;.\n// Omitindo parêntese do retorno func Sum(a int, b int) int { return a + b } // Agrupando variaveis por tipo func Sum(a, b int) int { return a + b } // Parâmetro de retorno nomeado func Sum(a int, b int) (c int) { c = a + b return } Um ponto interessante sobre a assinatura de função é que duas funções podem ter o mesmo tipo se elas tiverem a mesma sequência e tipo de entrada e a mesma sequência de tipos de resultado.\npackage main type TestFunc func(a int, b int) (int, int) func Test(a, b int) (int, int) { return a + b, a - b } // função declarada com parâmetros de retorno nomeados func Test2(a int, b int) (c int, d int) { c = a + b d = a - b return } func main() { var t TestFunc t = Test t(1, 2) // Atribuindo uma função com declaração diferente t = Test2 t(1, 2) } Perceba a variável declarada com tipo \u0026ldquo;TestFunc\u0026rdquo; com uma assinatura de função com dois argumentos entrada inteiros e dois inteiros na saída. Logo abaixo são declaradas duas funções que contém os mesmos tipos de entradas e saídas mas não tem a mesma forma de declaração. Essas maneiras diferentes de declarar as funções não influenciam e respeitam a sua assinatura. Como na função \u0026ldquo;main\u0026rdquo;, que uma variável \u0026ldquo;t\u0026rdquo; é declarada com o tipo acima e consegue receber as duas funções.\nFunções anônimas As funções anônimas também são conhecidas como funções literais. Geralmente são utilizadas para encapsulamento de lógica ou representação de expressões. Também quando a função tem curto período de vida e não tem a necessidade de reaproveitamento em outro lugar. Elas são declaradas na forma de funções regulares mas sem nome, podendo ser atribuídas diretamente a variáveis ou como parâmetro pra funções de ordem superior.\npackage main import \u0026#34;fmt\u0026#34; func main() { s := func(a, b int) int { return a + b }(2, 3) fmt.Println(s) } O exemplo acima declara uma função anônima de soma de dois números inteiros, perceba que deve ser omitido nome da função e que pode logo após sua declaração fazer a sua execução, passando em parênteses os argumentos necessários. Abaixo um outro exemplo do uso de uma função anônima no formato de parâmetro para uma função de nível superior.\npackage main import ( \u0026#34;fmt\u0026#34; ) // função que recebe um callback como argumento func process(data string, callback func(string)) { // faz algo com os dados fmt.Println(\u0026#34;Processando:\u0026#34;, data) // chama o callback com os dados processados callback(data) } func main() { // chamada da função \u0026#39;process\u0026#39; com um callback anônimo process(\u0026#34;dados de teste\u0026#34;, func(result string) { fmt.Println(\u0026#34;Callback recebido:\u0026#34;, result) }) } Funções Variádicas As funções variádicas são funções que podem ser invocadas com um número variável de argumentos. Existem exemplos familiares na biblioteca padrão do Go, como a função \u0026ldquo;fmt.Println()\u0026rdquo;, você pode passar uma infinidade de valores.\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Teste\u0026#34;, \u0026#34;Teste2\u0026#34;) fmt.Println(\u0026#34;Teste\u0026#34;, \u0026#34;Teste2\u0026#34;, \u0026#34;Teste3\u0026#34;, \u0026#34;Teste4\u0026#34;) } A declaração das funções variádicas tem um particularidade na sua definição.\nfunc fmt.Println(a ...any) (n int, err error) Analisando a assinatura da função \u0026ldquo;Println\u0026rdquo; do pacote \u0026ldquo;fmt\u0026rdquo; percebe-se que existe um argumento \u0026ldquo;a\u0026rdquo; que é declarado com reticência e logo após seu tipo, \u0026ldquo;any\u0026rdquo;. Essa declaração transforma essa variável em uma slice do tipo que pode ser iterada ou usada de acordo com o que uma slice do tipo permite.\npackage main import \u0026#34;fmt\u0026#34; func variadic(x ...int) int { total := 0 for _, v := range x { total += v } return total } func main() { fmt.Println(variadic(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) xi := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(variadic(xi...)) } Percebe-se que no exemplo acima a função \u0026ldquo;variadic\u0026rdquo; recebe um argumento na \u0026ldquo;x\u0026rdquo; do tipo inteiro, esse argumento é uma slice de inteiros. Na chamada função veja que pode-se passar valores separados por virgula como argumento da função ou passar um slice de inteiros seguindo por reticência a direita.\nUm ponto de atenção é que embora uma função variádica transforme a variável em um slice do tipo definido, ela tem assinatura diferente de uma função que você declara o tipo explicitamente.\npackage main type TestFunc func(a ...int) int func Test(a ...int) int { total := 0 for _, v := range a { total += v } return total } func Test2(a []int) int { total := 0 for _, v := range a { total += v } return total } func main() { var t TestFunc t = Test t(1, 2) t = Test2 //cannot use Test2 (value of type func(a []int) int) as TestFunc value in assignment t(1, 2) } Referências Introdução a Funções - IME USP A Linguagem de Programação Go Tags: Go, Algorithms, Function, Programming\n","date":"2024-03-21T00:00:00Z","permalink":"http://localhost:62975/posts/funcoes-anonimas-variaveis-go/","title":"Desvendando funções anônimas e variádicas em Go"},{"content":"Sobre a Palestra Apresentação sobre como integrar e aproveitar ferramentas de inteligência artificial para melhorar a produtividade no trabalho.\n","date":"2024-03-01T00:00:00Z","permalink":"http://localhost:62975/talks/ia-na-rotina-de-trabalho/","title":"Como utilizar inteligência artificial na sua rotina de trabalho"},{"content":"Sobre a Palestra Apresentação sobre instrumentalização de microsserviços escritos em Go utilizando OpenTelemetry, abordando conceitos de observabilidade e sua implementação na prática.\n","date":"2023-09-27T00:00:00Z","permalink":"http://localhost:62975/talks/instrumentalizando-microservicos-go-opentelemetry/","title":"Instrumentalizando microsserviços em Go com OpenTelemetry"},{"content":"Sobre a Palestra Apresentação introdutória sobre a linguagem de programação Python.\n","date":"2022-11-01T00:00:00Z","permalink":"http://localhost:62975/talks/onboard-python/","title":"Onboard Python"},{"content":"Sobre a Palestra Apresentação sobre Software Defined Network (SDN) e como implementá-lo utilizando soluções de software livre.\n","date":"2021-04-24T00:00:00Z","permalink":"http://localhost:62975/talks/sdn-com-software-livre/","title":"SDN Com Software Livre"},{"content":"Utilizando Selenium em alguns casos você precisa de uma única instância desse web driver em várias partes da sua aplicação, como exemplo uma aplicação para WhatsApp Web. Guardar a sessão do web driver e carregá-la em uma nova instância ao necessitar em mais de um serviço, pode acabar tendo perda de performance e flexibilidade da aplicação, então usar uma padrão de projeto como Singleton acaba sendo uma boa saída.\nO Singleton é um padrão de projeto criacional que permite a você garantir que uma classe tenha apenas uma instância, enquanto provê um ponto de acesso global para essa instância. Utilizar o padrão Singleton quando uma classe em seu programa deve ter apenas uma instância disponível para todos seus clientes; por exemplo, um objeto de base de dados único compartilhado por diferentes partes do programa.\nExemplo from selenium import webdriver from selenium.webdriver.chrome.options import Options class WebDriver: _instance = None def __new__(cls): if cls._instance is None: chrome_options = Options() chrome_options.add_argument(\u0026#34;--headless\u0026#34;) chrome_options.add_argument(\u0026#34;--no-sandbox\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-dev-shm-usage\u0026#34;) cls._instance = super().__new__(cls) cls._instance.driver = webdriver.Chrome( options=chrome_options, executable_path=\u0026#39;./chromedriver\u0026#39; ) return cls._instance def get_driver(self): return self.driver # Exemplo de uso driver1 = WebDriver().get_driver() driver2 = WebDriver().get_driver() print(driver1 == driver2) # True - Mesma instância Agora podemos garantir que a classe do web driver tenha apenas uma única instância, e podemos utilizá-la em toda aplicação.\nReferência Refactoring Guru - Singleton Tags: Python, Selenium, Singleton, Design Patterns\n","date":"2021-02-22T00:00:00Z","permalink":"http://localhost:62975/posts/singleton-python-selenium/","title":"Singleton Python para compartilhamento de instância do Web Driver Selenium"},{"content":"Em muitos cenários ao utilizar Selenium para web scraping com Python você não pode executar o webdriver com seu padrão. Este abre uma janela com a interface gráfica, como na execução em servidores onde não tem a disponibilidade desse recurso.\nHeadless é uma opção para executar seus testes sem a necessidade de abrir o browser em um ambiente gráfico, essa função executa o serviço em background, onde toda manipulação acontece por debaixo dos panos. Por sua vez Google Chrome webdriver disponibiliza esse recurso, mas em algumas das suas versões se encontram com problemas ao serem usadas. Nesse tutorial disponibilizarei a versão e o método no qual consegui executar meus projetos.\nO link para ChromeDriver na versão 2.41, lembrando que as ferramentas usadas são Python 3x e Selenium 3.\nExemplo from selenium import webdriver from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument(\u0026#34;--headless\u0026#34;) chrome_options.add_argument(\u0026#34;--no-sandbox\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-dev-shm-usage\u0026#34;) driver = webdriver.Chrome( options=chrome_options, executable_path=\u0026#39;./chromedriver\u0026#39; ) No exemplo acima é feito a importação do módulo de webdrive da biblioteca selenium juntamento com com a classe Options. Seguindo os passos, primeiramente é feito a instância da classe e o preenchimento dos argumentos necessários para usarmos o webdrive em modo Headless.\nPor fim é feito a instância do webdrive do Google Chrome, passando no primeiro parâmetro a instância da classe com as configurações necessárias e no segundo parâmetro o caminho no qual está localizado o o binário do chromedriver baixado pelo link disponibilizado.\nConclusão Em busca de diversos webdrives disponíveis como FireFox, Opera e etc e até mesmo a o Google Chrome, somente com o binário da versão 2.41 foi obtido êxito ao usar o recurso.\n","date":"2020-04-15T00:00:00Z","permalink":"http://localhost:62975/posts/selenium-python-headless-chrome/","title":"Selenium Python em Headless no Chrome"},{"content":"No desenvolvimento de software é muito comum usar linguagens de programação com o paradigma orientado a objetos e em suas bases de dados utilizam banco de dados relacionais. Embora tenha passado muito tempo, os bancos de dados relacionais continuam muito fortes no mercado, então começou-se a usar uma técnica de programação para abstrair a diferença entre esses paradigmas.\nORM é uma camada que mapeia o modelo de objetos (aplicação) e o modelo relacional (base de dados). Onde é abstraída a diferença entre os paradigmas, e o mesmo fará o papel de manager. Você não precisará escrever queries SQL, suas classes ajudarão a persistir os dados e buscá-los. Além de muitos recursos que diferenciam-se entre as ferramentas que utilizam dessa técnica.\nFrameworks que utilizam ORM Geralmente ORMs encontram-se em Frameworks, mas muitos desenvolvedores costumam desenvolver seu próprio. Uma lista de algumas ferramentas que utilizam ORM:\nDjango (Python) Laravel (PHP) Hibernate (Java) Ruby on Rails (Ruby) Sequelize (NodeJS) NHibernate (C#) Exemplo prático com Django Abaixo uma classe modelo em uma aplicação Django, ela conterá os campos e os comportamentos que serão armazenados. Cada modelo será equivalente a uma tabela na base de dados, e cada atributo é um campo específico e será mapeado para coluna no banco de dados. ID é um campo automático, mas seu comportamento pode ser substituído.\nfrom django.db import models class Pessoa(models.Model): primeiro_nome = models.CharField(max_length=30) segundo_nome = models.CharField(max_length=30) SQL equivalente:\nCREATE TABLE pessoa ( \u0026#34;id\u0026#34; serial NOT NULL PRIMARY KEY, \u0026#34;primeiro_nome\u0026#34; varchar(30) NOT NULL, \u0026#34;segundo_nome\u0026#34; varchar(30) NOT NULL ); Conclusão ORM é um excelente recurso, melhorando a produtividade do desenvolvedor, dando uma boa padronização ao seu projeto e lhe dando uma maior facilidade na manutenção.\n","date":"2018-01-26T00:00:00Z","permalink":"http://localhost:62975/posts/orm/","title":"O que é mapeamento objeto relacional? (ORM)"}]